<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>퀴즈 이펙트 04</title>
    <link rel="stylesheet" href="assets/css/quiz.css">
    <link rel="stylesheet" href="assets/css/ani.css">
    <style>
        .quiz__score {
            position: fixed;
            left: 20px;
            bottom: 20px;
            width: 70px;
            height: 50px;
            line-height: 50px;
            border-radius: 10px;
            background-color: #4f418c;
            color: #fff;
            text-align: center;
            font-size: 20px;
        }
    </style>
<body>
    <header id="header">
        <h1><a href="../javascript12.html">Quiz</a></h1>
        <nav id="nav">
            <ul>
                <li><a href="quizEffect01.html">1</a></li>
                <li><a href="quizEffect02.html">2</a></li>
                <li><a href="quizEffect03.html">3</a></li>
                <li><a href="quizEffect04.html">4</a></li>
                <li><a href="quizEffect05.html">5</a></li>
                <li><a href="quizEffect06.html">6</a></li>
                <li><a href="quizEffect07.html">7</a></li>
                <li><a href="quizEffect100.html">웹</a></li>
                <li class="active"><a href="quizEffect100-1.html">정</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="quiz__wrap">
        </div>
        <div class="quiz__score"></div>
    </main>
    <!-- //main -->

    <footer id="footer">
        <a href="mailto:yunyoungsik91@gmail.com">yunyoungsik91@gmail.com</a>
    </footer>
    <!-- //footer -->

    <script>
        // 선택자
        const quizWrap = document.querySelector(".quiz__wrap");
        const quizScore = document.querySelector(".quiz__score");
        let totalScore = 0;

        // 문제 정보
        const quizInfo = [
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "입출력 조작의 시간과 중앙처리장치의 처리시간과의 불균형을 보완하는 것은?",
                infoChoice : {
                    1: "채널장치",
                    2: "제어장치",
                    3: "터미널장치",
                    4: "콘솔장치"
                },
                infoAnswer : "1",
                infoDesc : "채널장치는 입출력 장치와 중앙처리장치 사이에서 데이터 전송을 담당하는 장치입니다. 채널장치는 입출력 장치와 직접 통신하여 입출력 작업을 처리하므로 중앙처리장치의 처리시간과 입출력 조작의 시간과의 불균형을 보완할 수 있습니다. 따라서 채널장치가 입출력 작업을 처리함으로써 시스템의 전체 처리 속도를 향상시킬 수 있습니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "명령어 형식(instruction format)에서 첫 번째 바이트에 기억되는 것은?",
                infoChoice : {
                    1: "operand",
                    2: "length",
                    3: "question mark",
                    4: "opcode"
                },
                infoAnswer : "4",
                infoDesc : "명령어 형식에서 첫 번째 바이트는 opcode(연산 코드)를 기억합니다. 이는 컴퓨터가 실행할 명령어의 종류를 나타내며, 해당 명령어가 어떤 작업을 수행할지를 결정합니다. 따라서 opcode가 명령어 형식에서 가장 중요한 역할을 하며, 첫 번째 바이트에 기억됩니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "반가산기(Half-Adder)의 논리회로도에서 자리올림이 발생하는 회로는?",
                infoChoice : {
                    1: "OR",
                    2: "NOT",
                    3: "ExclusiveOR",
                    4: "AND"
                },
                infoAnswer : "4",
                infoDesc : "반가산기의 논리회로도에서 자리올림이 발생하는 회로는 AND 입니다. 이는 반가산기에서 두 입력값이 모두 1일 때 자리올림이 발생하기 때문입니다. AND 게이트는 두 입력값이 모두 1일 때 출력값이 1이 되는 논리게이트이므로, 반가산기에서 자리올림을 나타내는 회로로 적합합니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "기억 장치 고유의 번지로서 0, 1, 2, 3, ...과 같이 16진수로 약속하여 순서대로 정해 놓은 번지는?",
                infoChoice : {
                    1: "절대번지",
                    2: "상대번지",
                    3: "필수번지",
                    4: "선택번지"
                },
                infoAnswer : "1",
                infoDesc : "절대번지는 기억 장치에서 고유하게 정해진 번지로, 다른 번지들과는 달리 상대적인 위치가 아닌 고정된 위치를 가지고 있습니다. 따라서 어떤 프로그램이 실행되더라도 절대번지는 항상 같은 위치에 있으며, 이를 이용하여 프로그램이 필요로 하는 데이터나 명령어를 정확하게 찾아내고 실행할 수 있습니다. 이러한 특징 때문에 절대번지는 컴퓨터 시스템에서 매우 중요한 역할을 합니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "2진수의 1011의 1의 보수는?",
                infoChoice : {
                    1: "0100",
                    2: "1000",
                    3: "0010",
                    4: "1010"
                },
                infoAnswer : "1",
                infoDesc : "1의 보수란, 모든 비트를 반전시킨 값입니다. 따라서 2진수 1011의 1의 보수는 0100이 됩니다. 이유는 다음과 같습니다.<br><br> - 2진수 1011의 비트를 반전시키면 0100이 됩니다.<br> - 1의 보수는 원래 수에서 모든 비트를 반전시킨 값이므로, 2진수 1011의 1의 보수는 0100이 됩니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "불(Boolean) 대수의 정리 중 틀린 것은?",
                infoChoice : {
                    1: "1+A=A",
                    2: "1·A=A",
                    3: "0+A=A",
                    4: "0·A=0"
                },
                infoAnswer : "1",
                infoDesc : "1+A=A는 불 대수의 항등원(identity) 법칙 중 하나로, 어떤 불 값 A와 항등원 1을 OR 연산하면 결과는 1이 되기 때문에 A와 같아진다. 따라서 1+A=A는 올바른 불 대수의 정리이다.<br><br> 나머지 보기들은 모두 올바른 불 대수의 정리이다. 1·A=A는 AND 연산에서 항등원이 1이기 때문에 올바르다. 0+A=A는 OR 연산에서 항등원이 0이기 때문에 올바르다. 마지막으로 0·A=0은 AND 연산에서 영원이 0이기 때문에 올바르다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "데이터 전송 명령어의 기능이 아닌 것은?",
                infoChoice : {
                    1: "상수값을 레지스터 또는 주기억장치로 전송",
                    2: "스택에 저장된 값을 레지스터로 전송",
                    3: "레지스터에 저장된 값을 스택으로 전송",
                    4: "레지스터에 저장된 값을 연산"
                },
                infoAnswer : "4",
                infoDesc : "데이터 전송 명령어는 데이터를 전송하는 기능을 수행하는 명령어이지만, 레지스터에 저장된 값을 연산은 데이터를 전송하는 것이 아니라, 레지스터에 저장된 값을 연산하는 기능이기 때문에 데이터 전송 명령어의 기능이 아닙니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 주소지정 방법 중 처리속도가 가장 빠른 것은?",
                infoChoice : {
                    1: "direct address",
                    2: "indirect address",
                    3: "calculated address",
                    4: "immediate address"
                },
                infoAnswer : "4",
                infoDesc : "처리속도가 가장 빠른 주소지정 방법은 immediate address 입니다. 이는 명령어 자체에 데이터 값을 포함하고 있기 때문에 추가적인 메모리 접근이 필요하지 않기 때문입니다. 따라서 처리속도가 가장 빠르며, 주로 상수 값을 다룰 때 사용됩니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "ASCII 코드에 대한 설명으로 잘못된 것은",
                infoChoice : {
                    1: "3개의 Zone비트를 가지고 있다.",
                    2: "16비트 코드로 미국 표준협회에서 개발하였다.",
                    3: "통신 제어용으로 사용한다.",
                    4: "128가지의 문자를 표현한다."
                },
                infoAnswer : "2",
                infoDesc : "ASCII 코드는 7비트 코드로 미국 표준협회에서 개발하였다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "1개의 입력선으로 들어오는 정보를 2n개의 출력선 중 1개를 선택하여 출력하는 회로는?",
                infoChoice : {
                    1: "멀티플렉서",
                    2: "인코더",
                    3: "디코더",
                    4: "디멀티플렉서"
                },
                infoAnswer : "4",
                infoDesc : "디멀티플렉서는 1개의 입력선으로부터 2n개의 출력선 중 1개를 선택하여 출력하는 회로이기 때문입니다. 다른 보기들은 입력선과 출력선의 개수가 다르거나, 입력선으로부터 정보를 해석하는 방식이 다르기 때문에 정답이 될 수 없습니다."
            },
            // 10
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "제어장치의 기능에 대한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "산술 및 논리연산을 실행하는 장치이다.",
                    2: "입·출력장치를 제어한다.",
                    3: "주기억장치에 기억된 명령을 꺼내어 해독한다.",
                    4: "프로그램카운터와 명령레지스터를 이용하여 명령어 처리순서를 제어한다."
                },
                infoAnswer : "1",
                infoDesc : "제어장치는 프로그램카운터와 명령레지스터를 이용하여 명령어 처리순서를 제어하고, 주기억장치에 기억된 명령을 꺼내어 해독하며, 입·출력장치를 제어합니다. 산술 및 논리연산을 실행하는 장치는 산술논리연산장치(ALU)입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "인터넷에 연결되어 있는 수많은 컴퓨터의 주소는 일정한 규칙에 따라 지어진다. 210.103.4.1과 같이 4개의 필드로 끊어서, (.)으로 분리하여 나타내는 컴퓨터 주소는?",
                infoChoice : {
                    1: "개인 ID",
                    2: "전자 우편 ID",
                    3: "IP주소",
                    4: "도메인 주소"
                },
                infoAnswer : "3",
                infoDesc : "10.103.4.1은 인터넷 프로토콜 주소(IP 주소)이다. IP 주소는 인터넷에 연결된 각 컴퓨터를 식별하기 위한 주소로, 인터넷에서 데이터를 주고받을 때 필요하다. 개인 ID는 개인을 식별하기 위한 ID이고, 전자 우편 ID는 이메일 주소를 나타내는 ID이며, 도메인 주소는 인터넷 상에서 웹사이트를 찾기 위한 주소이다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "주소를 지정하는 필드가 없는 0번지 명령어에서 Stack의 Top 포인터가 가리키는 오퍼랜드를 암시하여 이용하는 주소 방식은?",
                infoChoice : {
                    1: "Implied Mode",
                    2: "Immediate Mode",
                    3: "Direct Mode",
                    4: "Indirect Mode"
                },
                infoAnswer : "1",
                infoDesc : "0번지 명령어에서 주소를 지정하는 필드가 없기 때문에 오퍼랜드를 암시하여 사용하는 방식이며, 이를 Implied Mode라고 합니다. 다른 보기들은 각각 즉시 값을 사용하는 Immediate Mode, 직접적인 주소를 사용하는 Direct Mode, 간접적인 주소를 사용하는 Indirect Mode와 관련된 주소 지정 방식입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "10진수 23을 2진수로 변환하면?",
                infoChoice : {
                    1: "(10111)2",
                    2: "(11011)2",
                    3: "(10011)2",
                    4: "(11101)2"
                },
                infoAnswer : "1",
                infoDesc : "23을 2진수로 변환하는 방법은 다음과 같습니다.<br><br> 1. 23을 2로 나눕니다. 나머지는 1, 몫은 11입니다.<br> 2. 11을 2로 나눕니다. 나머지는 1, 몫은 5입니다.<br> 3. 5를 2로 나눕니다. 나머지는 1, 몫은 2입니다.<br> 4. 2를 2로 나눕니다. 나머지는 0, 몫은 1입니다.<br> 5. 1을 2로 나눕니다. 나머지는 1, 몫은 0입니다.<br><br> 나머지를 아래에서부터 위로 쓰면 (10111)2가 됩니다. 따라서 정답은 (10111)2입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "주기억 장치의 접근 시간과 CPU의 처리 속도 차이를 줄이기 위해 사용되는 것은?",
                infoChoice : {
                    1: "Magnetic Tapes",
                    2: "Magnetic Disks",
                    3: "Cache Memory",
                    4: "Virtual Memory"
                },
                infoAnswer : "3",
                infoDesc : "Cache Memory는 CPU와 주기억 장치 사이에 위치하여 CPU가 필요로 하는 데이터를 빠르게 제공함으로써 주기억 장치의 접근 시간과 CPU의 처리 속도 차이를 줄일 수 있습니다. 따라서 Cache Memory가 주기억 장치와 CPU 간의 데이터 전송 속도를 높이기 위해 사용됩니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "마이크로프로세서의 기능이 아닌 것은?",
                infoChoice : {
                    1: "기억 기능",
                    2: "메모리 관리",
                    3: "산술 및 논리 연산",
                    4: "제어 기능"
                },
                infoAnswer : "2",
                infoDesc : "마이크로프로세서는 기억 기능, 산술 및 논리 연산, 제어 기능을 수행하지만, 메모리 관리는 마이크로프로세서의 주요 기능 중 하나가 아닙니다. 메모리 관리는 운영체제의 역할이며, 운영체제는 메모리를 할당하고 관리하여 프로그램이 실행될 수 있도록 합니다. 따라서 메모리 관리는 마이크로프로세서의 기능이 아닙니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "디스크팩이 6장으로 구성되었을 때 사용하여 기록할 수 있는 면의 수는?",
                infoChoice : {
                    1: "6",
                    2: "8",
                    3: "10",
                    4: "12"
                },
                infoAnswer : "3",
                infoDesc : ""
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "프리젠테이션에서 프리젠테이션의 흐름을 기획한 것을 무엇이라 하는가?",
                infoChoice : {
                    1: "개체",
                    2: "슬라이드",
                    3: "매크로",
                    4: "시나리오"
                },
                infoAnswer : "4",
                infoDesc : "프리젠테이션에서는 발표 내용을 순서대로 구성하여 전달해야 합니다. 이때, 발표 내용의 순서와 흐름을 미리 계획하고 구성하는 것을 시나리오라고 합니다. 따라서, 시나리오는 프리젠테이션의 흐름을 기획한 것입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "스프레드시트의 기능과 거리가 먼 것은?",
                infoChoice : {
                    1: "데이터 연산결과를 사용자가 다양한 서식으로 자유롭게 표현한다.",
                    2: "입력된 자료 또는 계산된 자료를 가지고 여러 유형의 그래프를 작성한다.",
                    3: "동영상 처리 및 애니메이션 효과를 구현할 수 있다.",
                    4: "특정 자료의 검색, 추출 및 정렬을 한다."
                },
                infoAnswer : "3",
                infoDesc : "스프레드시트는 주로 데이터 처리와 관련된 기능을 제공하는 프로그램이기 때문에, 동영상 처리나 애니메이션 효과와 같은 멀티미디어 기능은 스프레드시트의 주요 기능과는 거리가 먼 것입니다. 이러한 멀티미디어 기능은 주로 프레젠테이션 소프트웨어나 비디오 편집 소프트웨어 등에서 제공되는 기능입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "SQL의 DML에 해당하지 않는 것은?",
                infoChoice : {
                    1: "INSERT",
                    2: "SELECT",
                    3: "CREATE",
                    4: "UPDATE"
                },
                infoAnswer : "3",
                infoDesc : "CREATE은 DDL(Data Definition Language)에 해당하며, 데이터베이스 객체를 생성, 수정, 삭제하는 명령어입니다. DML(Data Manipulation Language)은 데이터를 조작하는 명령어로 INSERT, SELECT, UPDATE 등이 포함됩니다. 따라서 CREATE은 DML에 해당하지 않습니다."
            },
            // 20
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "프레젠테이션에서 화면 전체를 전환하는 단위를 의미하는 것은?",
                infoChoice : {
                    1: "개체",
                    2: "개요",
                    3: "스크린 팁",
                    4: "슬라이드"
                },
                infoAnswer : "4",
                infoDesc : "프레젠테이션에서 화면 전체를 전환하는 단위는 슬라이드입니다. 슬라이드는 하나의 주제나 내용을 담고 있는 하나의 화면으로, 다른 슬라이드와 구분되어 있으며, 각각의 슬라이드는 개별적으로 편집이 가능합니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "3단계 스키마의 종류에 해당하지 않는 것은?",
                infoChoice : {
                    1: "외부 스키마",
                    2: "내부 스키마",
                    3: "개념 스키마",
                    4: "관계 스키마"
                },
                infoAnswer : "4",
                infoDesc : "관계 스키마는 2단계 스키마인 논리적 데이터 모델링에서 사용되는 개념으로, 데이터베이스의 구조와 제약 조건을 정의하는 것이 주요 목적입니다. 3단계 스키마에서는 외부 스키마, 내부 스키마, 개념 스키마가 있지만, 관계 스키마는 해당되지 않습니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "스프레드시트 작업에서 반복적으로 실행하는 경우에 한 번의 명령으로 자동화시켜 처리하는 기능은?",
                infoChoice : {
                    1: "뷰",
                    2: "정렬",
                    3: "필터",
                    4: "매크로"
                },
                infoAnswer : "4",
                infoDesc : "매크로는 스프레드시트 작업에서 반복적으로 실행하는 작업을 한 번의 명령으로 자동화시켜 처리하는 기능입니다. 따라서, 주어진 보기 중에서 매크로가 정답입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스를 사용하는 경우의 장점이 아닌 것은?",
                infoChoice : {
                    1: "데이터의 일관성 유지",
                    2: "데이터의 공용 사용",
                    3: "데이터의 무결성 유지",
                    4: "데이터 중복의 최대화"
                },
                infoAnswer : "4",
                infoDesc : "데이터 중복의 최대화는 데이터베이스를 사용하는 경우의 장점이 아닙니다. 이는 오히려 데이터 일관성과 무결성을 해치며, 데이터의 공용 사용을 어렵게 만들어 데이터베이스의 효율성을 떨어뜨릴 수 있습니다. 따라서 데이터 중복을 최소화하여 데이터 일관성과 무결성을 유지하며, 데이터의 공용 사용을 용이하게 하는 것이 데이터베이스를 사용하는 주요 장점 중 하나입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제의 프로세스 정의로 가장 거리가 먼 것은?",
                infoChoice : {
                    1: "실행중인 프로그램",
                    2: "프로그램을 실행하는 처리단위",
                    3: "프로세서가 할당되는 개체",
                    4: "데이터 저장 공간"
                },
                infoAnswer : "4",
                infoDesc : "운영체제의 프로세스는 실행중인 프로그램, 프로그램을 실행하는 처리단위, 프로세서가 할당되는 개체로 정의됩니다. 이 중에서 데이터 저장 공간은 프로세스의 일부분이지만, 프로세스의 정의에는 포함되지 않습니다. 따라서 데이터 저장 공간이 가장 거리가 먼 것입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 운영체제의 발전 단계를 가장 올바르게 나열한 것은?",
                infoChoice : {
                    1: "배치 처리→다중 프로그래밍→시분할 시스템",
                    2: "다중 프로그래밍→시분할 시스템→배치 처리",
                    3: "시분할 시스템→배치 처리→다중 프로그래밍",
                    4: "배치 처리→시분할 시스템→다중 프로그래밍"
                },
                infoAnswer : "1",
                infoDesc : "운영체제의 발전 단계는 배치 처리 → 다중 프로그래밍 → 시분할 시스템 순서로 진행되었다.<br><br> 배치 처리는 컴퓨터가 처음 개발될 당시에 사용되던 방식으로, 작업을 일괄적으로 처리하는 방식이다. 이후 다중 프로그래밍이 등장하면서 여러 개의 작업을 동시에 처리할 수 있게 되었다.<br><br> 하지만 다중 프로그래밍은 CPU를 공유하는 방식으로 작업을 처리하기 때문에, CPU 사용 시간을 분할하는 시분할 시스템이 등장하게 되었다. 이를 통해 여러 사용자가 동시에 컴퓨터를 사용할 수 있게 되었고, 대화형 컴퓨팅이 가능해졌다.<br><br> 따라서, 운영체제의 발전 단계는 배치 처리 → 다중 프로그래밍 → 시분할 시스템 순서로 진행되었다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS-DOS)에서 파일을 저장하고, 보관하는 것은?",
                infoChoice : {
                    1: "파일(File)",
                    2: "디렉터리(Directory)",
                    3: "트리(Tree)",
                    4: "자료구조(Data structure)"
                },
                infoAnswer : "2",
                infoDesc : "MS-DOS에서 파일을 저장하고 보관하기 위해서는 파일을 저장할 위치를 지정해야 합니다. 이때 사용되는 것이 디렉터리입니다. 디렉터리는 파일을 저장할 수 있는 폴더나 디렉터리를 의미하며, 파일을 저장할 위치를 지정하여 파일을 보관할 수 있습니다. 따라서 디렉터리가 파일을 저장하고 보관하는 데 필수적인 요소입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX 운영체제에 대한 설명으로 가장 거리가 먼 것은?",
                infoChoice : {
                    1: "다중 프로세스 운영체제이다.",
                    2: "Windows기반 운영체제이다.",
                    3: "다중 사용자 시스템이다.",
                    4: "주로 C언어로 작성된 운영체제이다."
                },
                infoAnswer : "2",
                infoDesc : "Windows는 UNIX와는 완전히 다른 운영체제 패밀리이기 때문에, UNIX 운영체제에 대한 설명에서 가장 거리가 먼 것은 Windows기반 운영체제이다. 입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98의 휴지통에 대한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "일반적으로 삭제된 파일이 저장되는 공간이다.",
                    2: "휴지통의 용량은 조절할 수 있다.",
                    3: "휴지통에 있는 파일을 직접 실행시키려면 해당 파일을 더블클릭한다.",
                    4: "휴지통 비우기를 실행하면 복구가 불가능해진다."
                },
                infoAnswer : "3",
                infoDesc : "휴지통에 있는 파일은 이미 삭제된 파일이기 때문에 해당 파일을 실행시키려면 더 이상 사용할 수 없다. 따라서 휴지통에 있는 파일을 직접 실행시키려면 해당 파일을 더블클릭한다.는 틀린 설명이다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98의 시스템 종료 대화 상자의 항목이 아닌 것은?",
                infoChoice : {
                    1: "시스템 종료",
                    2: "시스템 다시 시작",
                    3: "MS-DOS모드에서 시스템 다시 시작",
                    4: "사용자 전환"
                },
                infoAnswer : "4",
                infoDesc : "윈도 98에서 사용자 전환은 시스템 종료 대화 상자의 항목이 아닙니다. 이는 윈도 98에서는 다중 사용자 기능이 지원되지 않았기 때문입니다. 따라서 사용자 전환 기능이 없었으며, 이는 윈도 XP 이후 버전에서 추가되었습니다."
            },
            // 30
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "두 개의 파일의 차이가 있을 때 차이점이 나타난 바이트 위치와 행 번호를 표시하는 UNIX 명령어는?",
                infoChoice : {
                    1: "diff",
                    2: "cmp",
                    3: "comm",
                    4: "paste"
                },
                infoAnswer : "2",
                infoDesc : "cmp 명령어는 두 개의 파일을 비교하여 차이점이 있는 첫 번째 바이트의 위치와 행 번호를 출력합니다. diff 명령어는 두 파일의 차이점을 라인 단위로 비교하여 출력하며, comm 명령어는 두 파일의 공통된 라인과 고유한 라인을 출력합니다. paste 명령어는 두 파일의 라인을 병합하여 출력합니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "실행중인 프로그램이나 시스템을 중지시킬 수 있는 수행 중단기능(break on)을 설정할 수 있는 도스 파일은?",
                infoChoice : {
                    1: "io.sys",
                    2: "command.com",
                    3: "config.sys",
                    4: "autoexec.bat"
                },
                infoAnswer : "3",
                infoDesc : "config.sys 파일은 도스 부팅 시 시스템 설정을 지정하는 파일로, 수행 중단기능(break on)을 설정할 수 있는 명령어인 BREAK=을 포함하고 있기 때문에 정답입니다. io.sys는 도스의 핵심 파일이며, command.com은 도스의 명령어 해석기입니다. autoexec.bat은 부팅 시 자동으로 실행되는 배치 파일입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98에서 시동디스크(부팅디스크)를 만드는 기능은 어디에 있는가?",
                infoChoice : {
                    1: "내게 필요한 옵션",
                    2: "시스템",
                    3: "프로그램 추가/제거",
                    4: "디스플레이"
                },
                infoAnswer : "3",
                infoDesc : "윈도 98에서 시동디스크(부팅디스크)를 만드는 기능은 프로그램 추가/제거에 있습니다. 이는 시동디스크를 만들기 위해 필요한 파일들이 시스템에 이미 설치되어 있기 때문입니다. 따라서 이 기능을 사용하여 필요한 파일들을 선택하고 시동디스크를 만들 수 있습니다. 내게 필요한 옵션과 디스플레이는 시동디스크를 만드는 기능과는 관련이 없습니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "스풀링(Spooling)에 대한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "프로세서와 입/출력장치와의 속도차이를 해결하여 시스템의 효율을 높이는 방법이다.",
                    2: "스풀링의 방법은 출력장치로 직접 보내는 것이다.",
                    3: "출력시 출력할 데이터를 만날 때 마다 디스크로 보내 저장시키는 것이다.",
                    4: "프로그램 실행과 속도가 느린 입/출력을 이원화 한다."
                },
                infoAnswer : "2",
                infoDesc : "스풀링은 출력장치로 직접 보내는 것이 아니라, 출력할 데이터를 디스크에 저장한 후에 출력장치가 필요할 때 디스크에서 데이터를 가져와 출력하는 방식입니다. 이를 통해 프로세서와 입/출력장치 간의 속도차이를 해결하여 시스템의 효율을 높이는 것이 목적입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제의 데이터 처리 방식 중 처리할 데이터를 일정한 시간이 경과하거나 일정한 수준이 되었을 때 일시에 처리하는 것은?",
                infoChoice : {
                    1: "Batch Processing System",
                    2: "Multi-Processing System",
                    3: "Distributed Processing System",
                    4: "Time Sharing Processing System"
                },
                infoAnswer : "1",
                infoDesc : "Batch Processing System은 데이터를 일정한 시간이나 양에 따라 일괄적으로 처리하는 방식이기 때문에, 문제에서 설명한 데이터 처리 방식과 일치합니다. 다른 보기들은 데이터 처리 방식 중에서는 맞지만, 일정한 시간이나 양에 따라 일괄적으로 처리하는 것이 아니기 때문에 정답이 될 수 없습니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "컴퓨터에 하드디스크를 새로 장착하고 부팅 가능한 하드디스크로 만들기 위한 도스 명령어는?",
                infoChoice : {
                    1: "FORMAT C:/S",
                    2: "FORMAT C:/B",
                    3: "FORMAT C:/T",
                    4: "FORMAT C:/Q"
                },
                infoAnswer : "1",
                infoDesc : "정답은 FORMAT C:/S입니다. 이 명령어는 C 드라이브를 포맷하고, 시스템 파일을 복사하여 부팅 가능한 하드디스크로 만들기 위한 명령어입니다. /S 옵션은 시스템 파일을 복사하기 위한 옵션입니다. 다른 보기들은 각각 /B는 부트섹터를 복사하기 위한 옵션, /T는 테스트를 위한 옵션, /Q는 빠른 포맷을 위한 옵션입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98에서 작업 표시줄에 볼륨 조절 표시 아이콘을 생성할 수 있는 제어판의 아이콘은?",
                infoChoice : {
                    1: "사운드",
                    2: "멀티미디어",
                    3: "내게 필요한 옵션",
                    4: "시스템"
                },
                infoAnswer : "2",
                infoDesc : "정답은 멀티미디어입니다. 이는 볼륨 조절이 사운드와 관련이 있기 때문입니다. 멀티미디어 제어판에는 사운드와 관련된 설정이 포함되어 있으며, 따라서 볼륨 조절 표시 아이콘을 생성하기 위해서는 멀티미디어 제어판을 사용해야 합니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 신호대 잡음비(SNR)의 단위로 옳은 것은?",
                infoChoice : {
                    1: "baud",
                    2: "cycle",
                    3: "Hz",
                    4: "dB"
                },
                infoAnswer : "4",
                infoDesc : "신호대 잡음비(SNR)는 신호의 강도와 잡음의 강도를 비교한 값으로, 일반적으로 dB 단위로 표현됩니다. dB는 로그 스케일로 표현되는 데시벨(decibel)의 약자로, 신호의 강도나 전력의 비율을 나타내는 데 자주 사용됩니다. dB는 일반적으로 로그 스케일을 사용하여 크기가 매우 다른 값들을 비교하기 쉽게 만들어줍니다. 따라서 SNR도 dB 단위로 표현하여, 신호와 잡음의 강도 차이를 쉽게 파악할 수 있습니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 아날로그 CATV방송의 영상신호 전송방식은?",
                infoChoice : {
                    1: "FM 방식",
                    2: "FSK 방식",
                    3: "PCM 방식",
                    4: "AM 방식"
                },
                infoAnswer : "4",
                infoDesc : "아날로그 CATV방송의 영상신호 전송방식은 AM 방식입니다. 이는 영상신호가 주파수 변화에 따라 직접 변조되어 전송되기 때문입니다. FM 방식은 주파수 변화에 따라 음성신호가 변조되는 방식이며, FSK 방식은 주파수 변화에 따라 디지털 신호를 전송하는 방식입니다. PCM 방식은 디지털 신호를 아날로그 신호로 변환하여 전송하는 방식입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제의 수행업무에 해당하지 않는 것은?",
                infoChoice : {
                    1: "하드웨어 장치와 프로그램 수행 제어",
                    2: "CPU 스케줄링",
                    3: "기억 장치의 할당 및 회수",
                    4: "통신회선 신호 변환"
                },
                infoAnswer : "4",
                infoDesc : "운영체제는 컴퓨터 시스템의 하드웨어와 프로그램을 관리하고 제어하는 역할을 합니다. 따라서 통신회선 신호 변환은 하드웨어와 관련된 작업이지만, 운영체제의 수행업무에는 해당하지 않습니다. 이 작업은 네트워크 장비나 통신 시스템에서 수행됩니다."
            },
            // 40
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS-DOS)에서 1개의 하드디스크를 논리적으로 2개의 드라이브로 분할하고자 할 때 사용하는 명령어는?",
                infoChoice : {
                    1: "chkdsk",
                    2: "attrib",
                    3: "format",
                    4: "fdisk"
                },
                infoAnswer : "4",
                infoDesc : "fdisk 명령어는 하드디스크를 파티션으로 나누는 작업을 수행하는 명령어입니다. 따라서 하드디스크를 논리적으로 2개의 드라이브로 분할하고자 할 때 사용하는 명령어입니다. chkdsk는 디스크의 오류를 검사하고 수정하는 명령어, attrib은 파일이나 폴더의 속성을 변경하는 명령어, format은 디스크를 포맷하는 명령어입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98의 찾기 대화 상자에서 제공되는 탭이 아닌 것은?",
                infoChoice : {
                    1: "이름 및 위치",
                    2: "찾아보기",
                    3: "날짜",
                    4: "고급"
                },
                infoAnswer : "2",
                infoDesc : "윈도 98의 찾기 대화 상자에서 제공되는 탭 중 찾아보기는 파일 또는 폴더를 선택하는 데 사용되는 탭입니다. 다른 세 가지 탭은 파일 이름, 수정 날짜 및 파일 속성과 같은 검색 조건을 지정하는 데 사용됩니다. 따라서 찾아보기는 파일 또는 폴더를 선택하는 데 사용되므로 다른 탭과는 목적이 다르기 때문에 정답입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "10개 국(station)을 서로 망형 통신망을 구성시 최소로 필요한 통신 회선 수는?",
                infoChoice : {
                    1: "15",
                    2: "25",
                    3: "35",
                    4: "45"
                },
                infoAnswer : "4",
                infoDesc : "10개의 국(station)을 서로 망형 통신망으로 구성할 때, 모든 국(station)이 서로 통신할 수 있도록 하려면 각 국(station)마다 다른 9개의 국(station)과 통신할 수 있어야 합니다. 따라서, 첫 번째 국(station)은 9개의 국(station)과 통신할 수 있고, 두 번째 국(station)은 첫 번째 국(station)을 제외한 8개의 국(station)과 통신할 수 있으며, 세 번째 국(station)은 첫 번째와 두 번째 국(station)을 제외한 7개의 국(station)과 통신할 수 있습니다. 이와 같이 10개의 국(station)을 모두 연결하기 위해서는 9+8+7+6+5+4+3+2+1=45개의 통신 회선이 필요합니다. 따라서, 정답은 45입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "데이터 변조속도가 3600[Baud]이고 쿼드비트(Quad bit)를 사용하는 경우 전송속도는?",
                infoChoice : {
                    1: "14400",
                    2: "10800",
                    3: "9600",
                    4: "7200"
                },
                infoAnswer : "1",
                infoDesc : "쿼드비트는 2개의 비트를 동시에 전송할 수 있는 기술입니다. 따라서 3600[Baud]의 데이터 변조속도에서 1초당 전송 가능한 비트 수는 3600[Baud] x 1[초] = 3600[bps] 입니다. 이때 쿼드비트를 사용하면 2개의 비트를 동시에 전송할 수 있으므로 전송속도는 3600[bps] x 2[쿼드비트] = 7200[bps] 입니다. 하지만 문제에서는 전송속도를 bps가 아닌 Baud로 표기하였으므로, 전송속도는 7200[bps] / 2[쿼드비트] = 3600[Baud]이 됩니다. 따라서 정답은 14400[Baud]이 아닌 3600[Baud] x 4[쿼드비트] = 14400[Baud] 입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 LAN의 특성이라고 볼 수 없는 것은?",
                infoChoice : {
                    1: "고속의 정보전송이 가능하다.",
                    2: "자원의 공유가 가능하다.",
                    3: "외부 통신망의 제약을 받지 않는다.",
                    4: "방송 형태로 서비스 이용이 불가능하다."
                },
                infoAnswer : "4",
                infoDesc : "LAN은 지리적으로 가까운 범위 내에서 구성되는 네트워크로, 방송 형태로 서비스 이용이 불가능하다는 것은 LAN 내에서 모든 컴퓨터가 동시에 데이터를 받을 수 없다는 것을 의미한다. LAN은 패킷 전송 방식을 사용하며, 각 컴퓨터는 필요한 데이터만 받아서 처리하므로 방송 형태로 서비스 이용이 불가능하다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "RS-232C 25핀 인터페이스에서 데이터 전송(TXD)과 수신(RXD)에 해당되는 핀(Pin) 번호가 순서대로 옳은 것은?",
                infoChoice : {
                    1: "1,2",
                    2: "3,4",
                    3: "2,3",
                    4: "4,5"
                },
                infoAnswer : "3",
                infoDesc : "RS-232C 25핀 인터페이스에서 데이터 전송(TXD)은 핀 번호 2번에 해당하고, 데이터 수신(RXD)은 핀 번호 3번에 해당합니다. 따라서 정답은 2,3입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "PCM(Pulse Code Modulation)의 과정이 순서대로 옳은 것은?",
                infoChoice : {
                    1: "신호→양자화→표본화→부호화→복호화",
                    2: "신호→표본화→양자화→부호화→복호화",
                    3: "신호→표본화→양자화→복호화→부호화",
                    4: "신호→복호화→양자화→부호화→표본화"
                },
                infoAnswer : "2",
                infoDesc : "신호는 아날로그 신호로부터 디지털 신호로 변환됩니다. 이후에는 표본화가 이루어지는데, 이는 아날로그 신호를 일정한 시간 간격으로 샘플링하여 디지털 신호로 변환하는 과정입니다. 그 다음으로는 양자화가 이루어지는데, 이는 디지털 신호를 일정한 간격으로 분할하여 각 구간을 대표하는 값을 선택하는 과정입니다. 이후에는 부호화가 이루어지는데, 이는 디지털 신호를 이진수로 변환하는 과정입니다. 마지막으로는 복호화가 이루어지는데, 이는 부호화된 이진수를 디지털 신호로 변환하는 과정입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 전송선로의 1차 정수가 아닌 것은?",
                infoChoice : {
                    1: "저항",
                    2: "인덕턴스",
                    3: "정전용량",
                    4: "위상정수"
                },
                infoAnswer : "4",
                infoDesc : "위상정수는 전기 신호의 위상을 나타내는 값으로, 전송선로의 물리적인 특성과는 관련이 없습니다. 따라서 전송선로의 1차 정수가 아닌 것은 위상정수입니다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "컴퓨터를 이용하여 기존의 문자나 숫자 정보뿐만 아니라 텍스트, 이미지, 오디오, 비디오 등 여러 가지 미디어 형태의 정보를 통합하여 처리하는 기술을 무엇이라고 하는가?",
                infoChoice : {
                    1: "패킷무선망기술",
                    2: "전화망기술",
                    3: "멀티미디어기술",
                    4: "대용량전송기술"
                },
                infoAnswer : "3",
                infoDesc : "멀티미디어기술은 여러 가지 미디어 형태의 정보를 통합하여 처리하는 기술이다. 따라서 텍스트, 이미지, 오디오, 비디오 등 다양한 형태의 정보를 하나의 시스템에서 처리할 수 있어서 효율적인 정보 전달과 공유가 가능하다. 이에 비해 패킷무선망기술은 무선 통신망에서 데이터를 전송하는 기술, 전화망기술은 전화 통신망에서 음성 통화를 가능하게 하는 기술, 대용량전송기술은 대용량 데이터를 빠르게 전송하는 기술이다."
            },
            {
                infoDate : "2011년 10월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 데이터의 암호화와 압축을 수행하는 OSI 참조 모델의 계층은?",
                infoChoice : {
                    1: "응용 계층",
                    2: "표현 계층",
                    3: "세션 계층",
                    4: "전송 계층"
                },
                infoAnswer : "2",
                infoDesc : "데이터의 암호화와 압축은 데이터를 전송하기 전에 데이터를 변환하는 과정이므로, 이는 응용 계층에서 이루어지는 것이 아니라, 전송 계층 이하의 계층에서 이루어져야 합니다. 따라서, 전송 계층 이하의 계층 중에서 데이터의 암호화와 압축을 수행하는 계층은 표현 계층입니다. 표현 계층은 데이터의 형식을 변환하고, 데이터의 압축과 암호화를 수행하여 상위 계층에서 사용할 수 있는 형태로 만들어 전송 계층으로 전달합니다."
            },
            // 50
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "패리티 검사에 대한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "패리티 검사는 주로 저속 비동기방식에서 이용된다.",
                    2: "패리티 비트는 짝수(Even) 혹은 홀수 (Odd) 패리티로 사용된다.",
                    3: "전송 중 짝수개의 에러 비트가 발생해도 에러 검출이 가능하다.",
                    4: "패리티 검사를 통하여 전송 신뢰를 높일 수 있다."
                },
                infoAnswer : "3",
                infoDesc : "전송 중 짝수개의 에러 비트가 발생하면 패리티 비트도 함께 에러가 발생하여 검출이 불가능하다. 따라서 전송 중 짝수개의 에러 비트가 발생해도 에러 검출이 가능하다.는 틀린 설명이다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "ARQ 방식이란?",
                infoChoice : {
                    1: "에러를 정정하는 방식",
                    2: "부호를 정정하는 방식",
                    3: "에러를 검출하는 방식",
                    4: "에러를 검출하여 재전송을 요구하는 방식."
                },
                infoAnswer : "4",
                infoDesc : "ARQ 방식은 에러를 검출하여 재전송을 요구하는 방식입니다. 데이터를 전송할 때 일정한 크기의 패킷으로 나누어 전송하고, 수신측에서는 받은 패킷의 에러를 검출하여 송신측에 재전송을 요구합니다. 이를 통해 데이터 전송 중 발생하는 에러를 검출하고, 재전송을 통해 데이터의 신뢰성을 보장합니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "일반적으로 명령어의 패치 사이클 중에는 현재 수행하고 있는 명령어의 위치를 가리키고, 실행 사이클 중에는 바로 다음에 실행할 명령어의 위치를 가리키는 Register는?",
                infoChoice : {
                    1: "누산기(accumulator)",
                    2: "프로그램 카운터(program counter)",
                    3: "명령어 레지스터(instruction register)",
                    4: "범용 레지스터(general purpose register)"
                },
                infoAnswer : "2",
                infoDesc : "프로그램 카운터는 현재 수행 중인 명령어의 위치를 가리키는 레지스터입니다. 따라서 명령어의 패치 사이클 중에는 현재 수행 중인 명령어의 위치를, 실행 사이클 중에는 다음에 실행할 명령어의 위치를 가리킵니다. 이러한 이유로 프로그램 카운터가 정답입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "스택 연산에서 데이터를 삽입하거나 삭제하는 동작을 나타내는 것은?",
                infoChoice : {
                    1: "ADD, SUB",
                    2: "LOAD, STORE",
                    3: "PUSH, POP",
                    4: "MOV, MUL"
                },
                infoAnswer : "3",
                infoDesc : "스택 연산에서 데이터를 삽입하는 동작을 PUSH, 데이터를 삭제하는 동작을 POP이라고 합니다. 이는 스택 자료구조의 특성에 따라 가장 최근에 삽입된 데이터가 가장 먼저 삭제되어야 하기 때문입니다. 따라서 PUSH와 POP이 스택 연산에서 데이터를 삽입하거나 삭제하는 동작을 나타내는 것입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 제어장치에서 명령어의 실행 사이클에 해당하지 않는 것은?",
                infoChoice : {
                    1: "인출 주기(fetch cycle)",
                    2: "직접 주기(direct cycle)",
                    3: "간접 주기(indirect cycle)",
                    4: "실행 주기(execute cycle)"
                },
                infoAnswer : "2",
                infoDesc : "직접 주기는 명령어의 실행 사이클에 해당하지 않습니다. 이는 제어장치가 직접적으로 명령어를 실행하는 것이 아니라, 명령어가 필요로 하는 데이터나 주소를 가져오기 위해 메모리나 입출력장치와 통신하는 주기입니다. 따라서 직접 주기는 명령어 실행을 위한 사이클이 아니며, 인출 주기, 간접 주기, 실행 주기와는 구분됩니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "전가산기(Full Adder)는 어떤 회로로 구성되는가?",
                infoChoice : {
                    1: "반가산기 1개와 OR 게이트로 구성된다.",
                    2: "반가산기 1개와 AND 게이트로 구성된다.",
                    3: "반가산기 2개와 OR 게이트로 구성된다.",
                    4: "반가산기 2개와 AND 게이트로 구성된다."
                },
                infoAnswer : "3",
                infoDesc : "전가산기는 2개의 반가산기와 1개의 OR 게이트로 구성된다. 반가산기는 2개의 입력(A, B)과 2개의 출력(S, C)을 가지며, S는 A와 B의 합, C는 A와 B의 곱셈을 나타낸다. 따라서 전가산기는 두 개의 반가산기를 이용하여 3개의 입력(A, B, C)과 2개의 출력(S, C_out)을 가지며, S는 A와 B와 C의 합, C_out은 A와 B와 C의 곱셈을 나타낸다. 이때, 두 개의 반가산기의 출력 C를 OR 게이트의 입력으로 연결하여 C_out을 구한다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "CISC(Complex Instruction Set Computer)의 특징으로 틀린 것은?",
                infoChoice : {
                    1: "많은 수의 명령어",
                    2: "다양한 주소지정 방식",
                    3: "가변 길이 명령어 형식",
                    4: "단일 사이클의 명령어 실행"
                },
                infoAnswer : "4",
                infoDesc : "CISC의 특징 중 단일 사이클의 명령어 실행은 틀린 것입니다. CISC는 많은 수의 명령어와 다양한 주소지정 방식, 가변 길이 명령어 형식 등을 가지고 있으며, 명령어 실행에는 여러 사이클이 필요합니다. 이는 복잡한 명령어를 처리하기 위해 여러 단계로 나누어 처리해야 하기 때문입니다. 따라서 CISC는 단일 사이클의 명령어 실행이 아닌 다중 사이클의 명령어 실행을 수행합니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "EBCDIC 코드는 몇개의 Zone bit를 갖는가?",
                infoChoice : {
                    1: "1",
                    2: "2",
                    3: "3",
                    4: "4"
                },
                infoAnswer : "4",
                infoDesc : "EBCDIC 코드는 4개의 Zone bit를 갖습니다. 이는 EBCDIC 코드가 8비트로 구성되어 있으며, 각각의 비트가 다른 의미를 가지는데, 그 중 상위 4비트가 Zone bit이라고 불리며, 문자의 종류를 구분하는 역할을 합니다. 따라서 EBCDIC 코드는 4개의 Zone bit를 갖습니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "가상 메모리를 사용하는 목적으로 가장 옳은 것은?",
                infoChoice : {
                    1: "주기억 장치의 용량 제한으로 발생하는 문제 해결",
                    2: "CPU와 주기억 장치 사이의 속도 차이 개선",
                    3: "대용량 멀티미디어 데이터 보존을 위한 백업",
                    4: "컴퓨터 부팅에 사용되는 초기화 프로그램 보관"
                },
                infoAnswer : "1",
                infoDesc : "가상 메모리는 주기억 장치의 용량 제한으로 발생하는 문제를 해결하기 위해 사용됩니다. 주기억 장치의 용량은 한정되어 있기 때문에, 프로그램이 실행될 때 필요한 모든 데이터를 주기억 장치에 올리는 것은 불가능합니다. 따라서 가상 메모리를 사용하여 필요한 데이터만 주기억 장치에 올리고, 나머지는 하드 디스크 등의 보조 기억 장치에 저장하여 필요할 때마다 주기억 장치로 불러와 사용합니다. 이를 통해 주기억 장치의 용량 제한으로 인한 문제를 해결할 수 있습니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "8 bit를 1 word로 이용하는 컴퓨터에서 op code를 3bit 사용하면 인스트럭션을 몇개 사용할 수 있는가?",
                infoChoice : {
                    1: "4",
                    2: "6",
                    3: "8",
                    4: "16"
                },
                infoAnswer : "3",
                infoDesc : "3 bit로 표현할 수 있는 경우의 수는 2^3 = 8이므로, op code를 3 bit 사용하는 경우 인스트럭션을 8개까지 사용할 수 있습니다."
            },
            // 60
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "(A+1)·(B+1) + C의 논리식을 간단히 한 결과는?",
                infoChoice : {
                    1: "1",
                    2: "0",
                    3: "A",
                    4: "C"
                },
                infoAnswer : "1",
                infoDesc : "(A+1)·(B+1) + C = AB + A + B + 1 + C<br>= AB + A + B + C + 1<br>= (A+C)(B+1) + 1<br> 따라서, 답은 1이다. 이유는 (A+C)(B+1)은 항상 0 또는 1이 되기 때문에, 1을 더해도 결과는 변하지 않기 때문이다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 주소 일부를 접속하거나 계산하여 기억 장치에 접근 시킬 수 있는 주소의 일부분을 생략한 주소 표현 방식은?",
                infoChoice : {
                    1: "절대 주소",
                    2: "약식 주소",
                    3: "생략 주소",
                    4: "자료 자신"
                },
                infoAnswer : "2",
                infoDesc : "약식 주소는 주소 일부를 생략하여 기억 장치에 접근하는 주소 표현 방식입니다. 이는 주소의 일부를 생략함으로써 주소의 길이를 줄이고, 주소 계산을 간편하게 하기 위해 사용됩니다. 따라서 약식 주소는 다른 주소 표현 방식에 비해 간결하고 효율적입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "묵시적 주소지정 방식을 사용하는 산술 명령어는 주로 어떤 레지스터의 내용을 사용하여 연산을 수행하는가?",
                infoChoice : {
                    1: "PC",
                    2: "MBR",
                    3: "AC",
                    4: "SP"
                },
                infoAnswer : "3",
                infoDesc : "묵시적 주소지정 방식은 명령어에서 직접적으로 피연산자를 지정하지 않고, 대부분의 경우 AC(누산기) 레지스터의 내용을 사용하여 연산을 수행합니다. 이는 AC 레지스터가 CPU 내에서 가장 중요한 레지스터 중 하나이며, 산술 연산을 수행하는 데 필수적인 레지스터이기 때문입니다. 따라서 묵시적 주소지정 방식을 사용하는 산술 명령어에서는 AC 레지스터의 내용을 사용하여 연산을 수행합니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "제어 논리 장치(CLU)와 산술논리연산장치(ALU)의 실행 순서를 제어하기 위해 사용하는 레지스터는?",
                infoChoice : {
                    1: "Flag Register",
                    2: "Accumulator",
                    3: "Data Register",
                    4: "Status Register"
                },
                infoAnswer : "1",
                infoDesc : "Flag Register는 ALU에서 수행된 연산 결과에 따라 특정 상태를 나타내는 레지스터입니다. 예를 들어, 덧셈 연산을 수행한 후에는 결과가 0인지, 음수인지, 혹은 오버플로우가 발생했는지 등을 판단하여 해당 상태를 Flag Register에 저장합니다. 이렇게 저장된 상태 정보는 CLU에서 다음에 수행할 명령어를 결정하는 데 사용됩니다. 따라서 Flag Register는 CLU와 ALU의 실행 순서를 제어하기 위해 사용됩니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "CPU의 정보처리 속도 단위 중 초당 100만개의 명령어를 수행하는 것을 나타내는 단위는?",
                infoChoice : {
                    1: "MHZ",
                    2: "KIPS",
                    3: "MIPS",
                    4: "LIPS"
                },
                infoAnswer : "3",
                infoDesc : "MIPS는 Million Instructions Per Second의 약자로, 초당 100만개의 명령어를 수행하는 정보처리 속도를 나타내는 단위입니다. 따라서, 정답은 MIPS입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "순차적인 주소지정 등에 유리하며, 주소지정에 2개의 레지스터가 사용되는 방식은?",
                infoChoice : {
                    1: "직접 Addressing",
                    2: "간접 Addressing",
                    3: "상대 Addressing",
                    4: "색인 Addressing"
                },
                infoAnswer : "4",
                infoDesc : "색인 주소지정 방식은 주소지정에 2개의 레지스터를 사용하며, 첫 번째 레지스터는 배열의 시작 주소를 가리키고 두 번째 레지스터는 배열에서의 인덱스 값을 가리킵니다. 이 방식은 배열과 같은 순차적인 데이터 구조에서 유리하며, 데이터에 접근할 때 불필요한 연산을 줄일 수 있어 효율적입니다. 따라서 주어진 보기 중에서 색인 주소지정 방식이 가장 적절한 답입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "개인용 컴퓨터에 주로 사용되고 있는 중앙처리장치는 무엇으로 구성되는가?",
                infoChoice : {
                    1: "코프로세서",
                    2: "핸드쉐이킹",
                    3: "마이크로프로세서",
                    4: "초고밀도 집적회로"
                },
                infoAnswer : "4",
                infoDesc : "중앙처리장치는 컴퓨터의 핵심 부품으로, 컴퓨터의 모든 연산과 제어를 담당합니다. 이 중앙처리장치는 마이크로프로세서라는 작은 칩 형태로 구성되어 있습니다. 마이크로프로세서는 초고밀도 집적회로 기술을 이용하여 CPU, 캐시 메모리, 제어장치 등의 다양한 기능을 하나의 칩 안에 집적시켜 놓은 것입니다. 따라서 마이크로프로세서는 컴퓨터의 성능과 기능을 결정하는 가장 중요한 부품 중 하나입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : " JK 플립플롭에서 J=K=1일 때 출력 동작은?",
                infoChoice : {
                    1: "Set",
                    2: "Clear",
                    3: "No Change",
                    4: "Complement"
                },
                infoAnswer : "4",
                infoDesc : "JK 플립플롭에서 J=K=1일 때 출력 동작은 Complement입니다. 이는 J와 K가 모두 1이면, 이전 상태의 반대값을 출력하기 때문입니다. 즉, 이전 상태가 0이면 1을 출력하고, 이전 상태가 1이면 0을 출력합니다. 따라서 Complement가 정답입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "스프레드시트에서 조건을 부여하여 이에 맞는 자료들만 추출하여 표시하는 것을 무엇이라고 하는가?",
                infoChoice : {
                    1: "정렬",
                    2: "필터",
                    3: "매크로",
                    4: "프리젠테이션"
                },
                infoAnswer : "2",
                infoDesc : "조건에 맞는 자료들만 추출하여 표시하는 것은 필터링이라고 하며, 이를 스프레드시트에서 구현한 것이 필터 기능입니다. 따라서 정답은 필터입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "관계 데이터베이스에서 하나의 애트리뷰트가 취할수 있는 같은 타입의 모든 원자값의 집합을 무엇이라고 하는가?",
                infoChoice : {
                    1: "튜플(tuple)",
                    2: "도메인(domain)",
                    3: "스키마(schema)",
                    4: "인스턴스(instance)"
                },
                infoAnswer : "2",
                infoDesc : "도메인은 애트리뷰트가 취할 수 있는 모든 원자값의 집합을 의미합니다. 따라서 애트리뷰트의 타입을 결정하는 중요한 역할을 합니다. 튜플은 릴레이션에서 하나의 레코드를 의미하며, 스키마는 릴레이션의 구조를 정의하는 것을 의미합니다. 인스턴스는 릴레이션에 저장된 실제 데이터를 의미합니다."
            },
            // 70
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스 제어어(DCL)중 사용자에게 조작에 대한 권한을 부여하는 명령어는?",
                infoChoice : {
                    1: "IPTION",
                    2: "REVOKE",
                    3: "GRANT",
                    4: "VALUES"
                },
                infoAnswer : "3",
                infoDesc : "GRANT는 데이터베이스 사용자에게 조작에 대한 권한을 부여하는 명령어이기 때문입니다. 다른 옵션들은 데이터베이스 제어어 중 다른 목적을 가지고 있습니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "프리젠테이션에서 화면 전체를 전환하는 단위를 의미하는 것은?",
                infoChoice : {
                    1: "개체",
                    2: "개요",
                    3: "스크린 팁",
                    4: "슬라이드"
                },
                infoAnswer : "4",
                infoDesc : "슬라이드는 프리젠테이션에서 화면 전체를 전환하는 단위를 의미합니다. 이는 프리젠테이션의 각 페이지를 나타내며, 각 슬라이드는 텍스트, 이미지, 도표 등의 다양한 요소를 포함할 수 있습니다. 따라서 슬라이드는 프리젠테이션의 핵심적인 구성 요소 중 하나입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스 설계 단계를 순서대로 기술한 것은?",
                infoChoice : {
                    1: "논리적 설계 → 개념적 설계 → 물리적 설계",
                    2: "논리적 설계 → 물리적 설계 → 개념적 설계",
                    3: "개념적 설계 → 물리적 설계 → 논리적 설계",
                    4: "개념적 설계 → 논리적 설계 → 물리적 설계"
                },
                infoAnswer : "4",
                infoDesc : "데이터베이스 설계 단계는 개념적 설계, 논리적 설계, 물리적 설계 순서로 진행됩니다. 이는 데이터베이스 설계의 추상화 수준이 점차 하향되는 과정을 반영합니다. 개념적 설계는 업무 프로세스와 개체 간의 관계를 모델링하고, 논리적 설계는 개념적 모델을 데이터베이스 관계 모델로 변환하며, 물리적 설계는 논리적 모델을 실제 데이터베이스 시스템에 구현하는 과정입니다. 따라서, 개념적 설계가 가장 추상화된 수준에서 시작하여 물리적 설계로 이어지는 순서가 올바른 답안입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스에서 정보 부재를 명시적으로 표현하기 위해 사용하는 특수한 데이터 값은?",
                infoChoice : {
                    1: "널(null)",
                    2: "공백(blank)",
                    3: "샵(#)",
                    4: "영(zero)"
                },
                infoAnswer : "1",
                infoDesc : "정답은 널(null)입니다.<br><br>널(null)은 데이터베이스에서 정보 부재를 명시적으로 표현하기 위해 사용하는 특수한 데이터 값입니다. 이는 데이터베이스에서 해당 필드에 값이 없음을 나타내며, 공백(blank)이나 샵(#) 또는 영(zero)와는 다릅니다.<br><br> 공백(blank)은 값이 없는 것이 아니라, 공백 문자열이라는 값이 존재하는 것이며, 샵(#)이나 영(zero)는 실제 값이 존재하는 것이기 때문입니다.<br><br> 따라서, 널(null)은 데이터베이스에서 정보 부재를 명확하게 표현하기 위해 사용되며, 다른 값들과는 구분되는 특수한 데이터 값입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : " 스프레드시트에 행과 열이 교차되면서 만들어지는 각각의 사각형을 무엇이라고 하는가?",
                infoChoice : {
                    1: "셀",
                    2: "차수",
                    3: "카디널리티",
                    4: "슬라이드"
                },
                infoAnswer : "1",
                infoDesc : "스프레드시트에서 행과 열이 교차되면서 만들어지는 각각의 사각형은 셀이라고 부릅니다. 이 셀 안에는 데이터나 수식 등이 입력될 수 있습니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "하나 이상의 기본 테이블로 부터 유도되어 만들어 지는 가상 테이블은?",
                infoChoice : {
                    1: "뷰(VIEW)",
                    2: "유리창(WINDOW)",
                    3: "스키마(SCHEMA)",
                    4: "도메인(DOMAIN)"
                },
                infoAnswer : "1",
                infoDesc : "뷰는 하나 이상의 기본 테이블로부터 유도되어 만들어지는 가상 테이블입니다. 즉, 실제 데이터를 저장하고 있는 테이블이 아니라 다른 테이블에서 필요한 데이터를 추출하여 가상으로 만들어진 테이블입니다. 따라서 뷰는 데이터를 중복해서 저장하지 않고, 기존의 데이터를 활용하여 필요한 정보를 제공하는 데에 유용합니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "테이블을 제거할 때 사용하는 SQL 명령어는?",
                infoChoice : {
                    1: "DELETE",
                    2: "DROP",
                    3: "VIEW",
                    4: "ALTER"
                },
                infoAnswer : "2",
                infoDesc : "정답은 DROP입니다.<br><br> DELETE는 데이터를 삭제하는 명령어이고, VIEW는 데이터를 조회하는 가상 테이블을 생성하는 명령어입니다. ALTER는 테이블 구조를 변경하는 명령어입니다.<br><br> 반면에 DROP은 테이블 자체를 삭제하는 명령어입니다. 즉, 해당 테이블의 모든 데이터와 구조를 삭제하게 됩니다. 따라서 테이블을 완전히 제거하고 싶을 때 사용하는 명령어입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX 에서 파일을 삭제할 때 사용되는 명령어는?",
                infoChoice : {
                    1: "ls",
                    2: "cp",
                    3: "pwd",
                    4: "rm"
                },
                infoAnswer : "4",
                infoDesc : "정답은 rm 입니다. rm은 remove의 약자로, 파일이나 디렉토리를 삭제하는 명령어입니다. ls는 파일 목록을 보여주는 명령어, cp는 파일을 복사하는 명령어, pwd는 현재 작업 중인 디렉토리의 경로를 보여주는 명령어입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS-DOS)의 명령어 중 비교적 자주 사용되며 실행과정이 간단하고 별도의 파일 형태를 갖지 않아 언제든지 실행이 가능한 것은?",
                infoChoice : {
                    1: "SORT",
                    2: "CLS",
                    3: "SYS",
                    4: "FDISK"
                },
                infoAnswer : "2",
                infoDesc : "CLS는 화면을 지우는 명령어로, 실행과정이 간단하고 별도의 파일 형태를 갖지 않아 언제든지 실행이 가능합니다. 또한, 자주 사용되는 명령어 중 하나이며, 사용자가 입력한 명령어와 결과를 구분하기 위해 화면을 지우는 경우에 자주 사용됩니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98의 시작버튼 위에서 마우스의 오른쪽 버튼을 눌렀을때 나타나는 메뉴가 아닌 것은?",
                infoChoice : {
                    1: "열기",
                    2: "탐색",
                    3: "설정",
                    4: "찾기"
                },
                infoAnswer : "3",
                infoDesc : "위 메뉴에서 열기, 탐색, 찾기는 파일 및 폴더를 관리하는 기능과 검색 기능을 제공하는 메뉴이지만, 설정은 시스템 설정을 변경하는 기능을 제공하는 메뉴이기 때문에 다른 메뉴와는 목적이 다르기 때문입니다."
            },
            // 80
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX 시스템의 구성을 크게 세 부분으로 나눌때 해당하지 않는 것은?",
                infoChoice : {
                    1: "Block",
                    2: "Kernel",
                    3: "Shell",
                    4: "Utility"
                },
                infoAnswer : "1",
                infoDesc : "Block은 UNIX 시스템의 구성 요소 중 하나가 아닙니다. UNIX 시스템의 구성 요소는 다음과 같습니다.<br><br> 1. Kernel: 시스템의 핵심 부분으로, 하드웨어와 소프트웨어 간의 인터페이스 역할을 합니다.<br> 2. Shell: 사용자와 시스템 간의 인터페이스로, 명령어를 입력하고 결과를 출력합니다.<br> 3. Utility: 시스템 관리를 위한 유틸리티 프로그램으로, 파일 관리, 프로세스 관리, 네트워크 관리 등의 기능을 제공합니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "다음중 프로그래밍 시스템 내에서 서로 다른 프로세스가 일어날수 없는 사건을 무한정 기다리고 있는 것은?",
                infoChoice : {
                    1: "세마포어",
                    2: "가비지 수집",
                    3: "코루틴",
                    4: "교착상태"
                },
                infoAnswer : "4",
                infoDesc : "교착상태는 서로 다른 프로세스가 일어날 수 없는 상황에서 무한정 기다리고 있는 상태를 말합니다. 이는 두 개 이상의 프로세스가 서로 상대방이 가지고 있는 자원을 사용하려고 기다리면서 무한정 대기하는 상황에서 발생합니다. 이러한 상황에서는 모든 프로세스가 대기 상태에 빠져 작업이 진행되지 않으므로 시스템이 멈추게 됩니다. 따라서 교착상태는 프로그래밍 시스템에서 매우 위험한 상황으로 간주됩니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제(Operating System)의 목적이 아닌 것은?",
                infoChoice : {
                    1: "반환 시간 증가",
                    2: "처리 능력 향상",
                    3: "사용 가능도 향상",
                    4: "신뢰도 향상"
                },
                infoAnswer : "1",
                infoDesc : "운영체제의 목적은 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상 등을 포함합니다. 하지만 반환 시간 증가는 운영체제의 목적이 아닙니다. 반환 시간은 작업이 시작되고 완료될 때까지 걸리는 시간을 의미하며, 이는 하드웨어의 성능과 관련이 있습니다. 따라서 반환 시간을 줄이는 것은 운영체제의 목적이 아니라 하드웨어의 개선에 의해 달성됩니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98에서 한 번의 마우스 조작만으로 현재 실행중인 응용프로그램 사이를 오가며 작업할 수 있는 환경을 제공하는 것은?",
                infoChoice : {
                    1: "바탕화면",
                    2: "내 컴퓨터",
                    3: "시작 버튼",
                    4: "작업 표시줄"
                },
                infoAnswer : "4",
                infoDesc : "작업 표시줄은 현재 실행중인 응용프로그램들의 아이콘을 보여주며, 마우스 클릭 한 번으로 해당 프로그램으로 바로 이동할 수 있도록 제공합니다. 따라서 작업 표시줄을 통해 현재 실행중인 여러 프로그램들 사이를 쉽게 오가며 작업할 수 있습니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS-DOS)에서 attrib 명령어의 옵션에 대한 설명으로 옳지 않은 것은?",
                infoChoice : {
                    1: "백업 파일 속성 : A",
                    2: "시스템 파일 속성 : S",
                    3: "읽기 전용 파일 속성 : P",
                    4: "숨김 파일 속성 : H"
                },
                infoAnswer : "3",
                infoDesc : "정답은 읽기 전용 파일 속성 : P입니다.<br><br> P는 파일 속성 변경 금지를 의미하는 것이 아니라 읽기 전용을 의미합니다. 따라서 이 옵션을 사용하면 해당 파일을 수정할 수 없고 읽기만 가능하게 됩니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS_DOS)의 필터(Filter)명령어 중 하나 또는 여러개의 파일에서 특정한 문자열을 검색하는 명령어는?",
                infoChoice : {
                    1: "FIND",
                    2: "MORE",
                    3: "SORT",
                    4: "SEARCH"
                },
                infoAnswer : "1",
                infoDesc : "정답은 FIND입니다. FIND 명령어는 하나 또는 여러개의 파일에서 특정한 문자열을 검색하는 명령어로, 다른 보기인 MORE, SORT, SEARCH는 이와 다른 기능을 수행합니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98의 제어판에서 MIDI(Musical Instrument Digital Interface)형식의 음악 파일을 재생하는데 필요한 드라이브 파일을 설정하는 것은?",
                infoChoice : {
                    1: "시스템",
                    2: "멀티미디어",
                    3: "사운드",
                    4: "디스플레이"
                },
                infoAnswer : "2",
                infoDesc : "MIDI 형식의 음악 파일은 멀티미디어 기능을 사용하여 재생되기 때문에, MIDI 드라이브 파일을 설정하는 것은 멀티미디어 제어판에서 이루어져야 합니다. 따라서 정답은 멀티미디어입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도 98의 폴더명에 대한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "하나의 폴더 내에 동일한 이름의 폴더가 존재할 수 없다.",
                    2: "폴더명은 공백을 포함할 수 없다.",
                    3: "폴더의 이름은 255자 이내로 작성한다.",
                    4: "?, \, / 는 폴더이름으로 사용할 수 없다."
                },
                infoAnswer : "2",
                infoDesc : "폴더명에 공백을 포함하면 파일 시스템에서 경로를 인식할 때 공백을 구분자로 인식하여 경로를 찾을 수 없게 되기 때문입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "윈도98에서 [디스크 조각 모음]에 관한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "조각 모음을 하는데 걸리는 시간은 볼륨에 있는 파일의 수와 크기, 조각난 양 등에 따라 달라진다.",
                    2: "컴퓨터 시스템의 속도를 향상시키는 방법 중 하나이다.",
                    3: "디스크를 효율적으로 사용하기 위해 파일을 정리하는 것이다.",
                    4: "CD-ROM 드라이브 및 네트워크 드라이브에서도 디스크 조각모음을 수행할 수 있다."
                },
                infoAnswer : "4",
                infoDesc : "CD-ROM 드라이브와 네트워크 드라이브는 읽기 전용이기 때문에 디스크 조각모음을 수행할 수 없습니다. 디스크 조각모음은 하드 디스크 드라이브에서만 수행할 수 있습니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX에서 사용할 수 있는 편집기가 아닌 것은?",
                infoChoice : {
                    1: "ed",
                    2: "vi",
                    3: "ex",
                    4: "et"
                },
                infoAnswer : "4",
                infoDesc : "정답은 et입니다. ed, vi, ex는 모두 UNIX에서 사용 가능한 편집기입니다. 하지만 et는 UNIX에서 사용할 수 없는 편집기입니다."
            },
            // 90
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : " UNIX 명령과 MS-DOS 명령의 기능이 서로 다르게 연결된 것은?",
                infoChoice : {
                    1: "ls - dir",
                    2: "cp - copy",
                    3: "rd - rm",
                    4: "cd - cd"
                },
                infoAnswer : "3",
                infoDesc : "rd 명령은 MS-DOS에서 디렉토리를 삭제하는 명령이고, rm 명령은 UNIX에서 파일이나 디렉토리를 삭제하는 명령입니다. 따라서 rd - rm은 MS-DOS에서 디렉토리를 삭제하고, UNIX에서 파일이나 디렉토리를 삭제하는 명령이 서로 다르게 연결된 것입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX에 대한 설명으로 옳지 않은 것은?",
                infoChoice : {
                    1: "사용자의 명령으로 시스템이 수행되고 그에 따른 결과를 나타내 주는 대화식 운영체제 이다.",
                    2: "여러 프로그램을 동시에 여러 개를 실행시킬 수 있다.",
                    3: "파일 시스템이 배열 형태가 선형적 구조로 되어 있다.",
                    4: "표준 입출력을 통해 명령어와 명령어가 파이프라인으로 연결된다."
                },
                infoAnswer : "3",
                infoDesc : "파일 시스템이 배열 형태가 선형적 구조로 되어 있다는 설명은 옳지 않습니다. UNIX 파일 시스템은 트리 구조로 되어 있으며, 각 디렉토리는 그 안에 있는 파일과 하위 디렉토리를 가리키는 포인터를 포함하고 있습니다. 이러한 구조는 파일 및 디렉토리를 쉽게 찾고 관리할 수 있도록 도와줍니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 도스(MS-DOS) 명령어에 대한 설명으로 옳은 것은?",
                infoChoice : {
                    1: "ren : 디렉터리를 지운다.",
                    2: "find : 파일의 목록을 보여준다.",
                    3: "more : 화면을 깨끗이 지운다.",
                    4: "cd : 특정 디렉터리로 이동한다."
                },
                infoAnswer : "4",
                infoDesc : "cd 명령어는 change directory의 약자로, 현재 작업 중인 디렉터리를 변경하여 특정 디렉터리로 이동하는 명령어입니다. 디렉터리는 파일이 저장되는 폴더를 의미하며, cd 명령어를 사용하여 디렉터리를 변경하면 해당 디렉터리 내의 파일들을 조작할 수 있습니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 도스(MS-DOS) XCOPY 명령어에 대한 설명으로 옳지 않는 것은?",
                infoChoice : {
                    1: "XCOPY는 파일과 하위 디렉토리를 한꺼번에 복사해 준다.",
                    2: "XCOPY 명령에서 HIDDEN FILE은 복사되지 않는다.",
                    3: "XCOPY는 + 기호를 사용하는 파일 합치기 기능이 있다.",
                    4: "XCOPY는 외부 명령어이다."
                },
                infoAnswer : "3",
                infoDesc : "XCOPY는 + 기호를 사용하는 파일 합치기 기능이 없다. XCOPY는 파일과 하위 디렉토리를 한꺼번에 복사해 주는 명령어이며, HIDDEN FILE은 복사되지 않는다. XCOPY는 내장 명령어이다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "HDLC(High-level Data Link Control) 프레임(Frame)을 구성하는 순서로 바르게 열거한 것은?",
                infoChoice : {
                    1: "플래그, 주소부, 정보부, 제어부, 검색부, 플래그",
                    2: "플래그, 주소부, 제어부, 정보부, 검색부, 플래그",
                    3: "플래그, 검색부, 주소부, 정보부, 제어부, 플래그",
                    4: "플래그, 제어부, 주소부, 정보부, 검색부, 플래그"
                },
                infoAnswer : "2",
                infoDesc : "HDLC 프레임은 플래그로 시작하여 플래그로 끝나며, 주소부, 제어부, 정보부, 검색부의 순서로 구성됩니다. 따라서 플래그, 주소부, 제어부, 정보부, 검색부, 플래그가 올바른 순서입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "다음중 PCM 전송에서 송신측 과정은?",
                infoChoice : {
                    1: "음성 → 양자화 → 표본화 → 부호화",
                    2: "음성 → 복호화 → 변조화 → 부호화",
                    3: "음성 → 2진화 → 압축화 →부호화",
                    4: "음성 → 표본화 → 양자화 → 부호화"
                },
                infoAnswer : "4",
                infoDesc : "PCM 전송에서는 먼저 음성 신호를 표본화하여 아날로그 신호를 디지털 신호로 변환합니다. 그리고 양자화를 통해 디지털 신호를 일정한 간격으로 분할하고, 각 구간에서 가장 근접한 값을 선택하여 정확도를 조금 떨어뜨리지만 데이터 양을 줄입니다. 마지막으로 부호화를 통해 디지털 신호를 전송 가능한 형태로 변환합니다. 따라서 음성 → 표본화 → 양자화 → 부호화가 정답입니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "주파수분할 다중화 방식에서 각 채널간 간섭을 막기 위해서 일종의 완충지역 역할을 하는 것은?",
                infoChoice : {
                    1: "서브 채널(Sub-CH)",
                    2: "채널 밴드(CH Band)",
                    3: "채널 세트(CH Set)",
                    4: "가드 밴드(Guard Band)"
                },
                infoAnswer : "4",
                infoDesc : "주파수분할 다중화 방식에서 각 채널간 간섭을 막기 위해서는 인접한 채널들 사이에 일정한 주파수 간격을 두어야 합니다. 이때, 이 주파수 간격을 가드 밴드라고 합니다. 가드 밴드는 인접한 채널들의 주파수가 서로 겹치지 않도록 하여 간섭을 방지하고, 안정적인 통신을 가능하게 합니다. 따라서, 가드 밴드는 주파수분할 다중화 방식에서 매우 중요한 역할을 합니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "IP 주소 198.0.46.201 의 기본 마스크는?",
                infoChoice : {
                    1: "255.0.0.0",
                    2: "255.255.0.0",
                    3: "255.255.255.0",
                    4: "255.255.255.255"
                },
                infoAnswer : "3",
                infoDesc : "IP 주소 198.0.46.201은 클래스 C 주소이므로 기본 마스크는 255.255.255.0 입니다. 이는 첫 3 옥텟은 네트워크 주소를 나타내고, 마지막 옥텟은 호스트 주소를 나타내기 때문입니다. 따라서, 마지막 옥텟에서 0은 네트워크 주소를, 255는 브로드캐스트 주소를 나타내며, 1부터 254까지는 호스트 주소로 사용됩니다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "PCM 방식에서 표본화 주파수가 8[khz]라 하면 이때 표본화 주기는?",
                infoChoice : {
                    1: "125[㎲]",
                    2: "100[㎲]",
                    3: "85[㎲]",
                    4: "8[㎲]"
                },
                infoAnswer : "1",
                infoDesc : "CM 방식에서 표본화 주파수가 8[khz]이므로 1초당 8000번의 표본화가 이루어진다. 따라서 표본화 주기는 1/8000초이며, 이를 계산하면 125[㎲]이 된다. 즉, 1초를 8000등분하여 각 등분의 길이가 125[㎲]이 된다. 따라서 정답은 125[㎲]이다."
            },
            {
                infoDate : "2011년 7월",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 트래픽 제어에 해당되지 않는 것은?",
                infoChoice : {
                    1: "흐름제어",
                    2: "교착회피 제어",
                    3: "오류제어",
                    4: "폭주 제어"
                },
                infoAnswer : "3",
                infoDesc : "트래픽 제어는 네트워크에서 발생하는 데이터 흐름을 제어하는 것을 말합니다. 이 중 오류제어는 데이터의 정확성과 완전성을 보장하기 위한 것으로, 트래픽 제어와는 관련이 없습니다. 따라서 오류제어가 트래픽 제어에 해당되지 않습니다."
            },
            // 100
        ];

        // 문제 출력
        const updateQuiz = () => {
            const quizArray = [];

            quizInfo.forEach((quiz, index) => {
                quizArray.push(`
                    <div class="quiz">
                        <div class="quiz__header">${quiz.infoDate} ${quiz.infoType}</div>
                        <!-- //quiz__header -->
                        <div class="quiz__main">
                            <div class="quiz__question">
                                ${index+1}. ${quiz.infoQuestion}
                            </div>
                            <div class="quiz__choice">
                                
                                <label for="choice1-${index}">
                                    <input type="radio" id="choice1-${index}" name="choice${index}" value="1">
                                    <span>${quiz.infoChoice[1]}</span>
                                </label>
                                <label for="choice2-${index}">
                                    <input type="radio" id="choice2-${index}" name="choice${index}" value="2">
                                    <span>${quiz.infoChoice[2]}</span>
                                </label>
                                <label for="choice3-${index}">
                                    <input type="radio" id="choice3-${index}" name="choice${index}" value="3">
                                    <span>${quiz.infoChoice[3]}</span>
                                </label>
                                <label for="choice4-${index}">
                                    <input type="radio" id="choice4-${index}" name="choice${index}" value="4">
                                    <span>${quiz.infoChoice[4]}</span>
                                </label>
                            </div>
                            <div class="quiz__answer none">
                                ${quiz.infoAnswer}
                            </div>
                            <div class="quiz__desc none">
                                ${quiz.infoDesc}
                            </div>
                        </div>
                        <!-- //quiz__main -->
                        <div class="quiz__footer">
                            <button class="quiz__confirm" data-index="${index}">정답 확인하기</button>
                        </div>
                        <!-- //quiz__footer -->
                    </div>
                    <div class="quiz__score"></div>
                `);
            });

            quizWrap.innerHTML = quizArray.join(" ");
        }
        updateQuiz();
        
        // // 정답 확인
        // const answerQuiz = () => {
        //     const quizChoices = document.querySelectorAll(".quiz__choice");

        //     // 사용자가 체크한 정답 == 답안지 정답
        //     quizInfo.forEach((quiz, index) => {
        //         const userSelector = `input[name=choice${index}]:checked`
        //         const quizSelectorWrap = quizChoices[index];
        //         const userAnswer = quizSelectorWrap.querySelector(userSelector);

        //         if(userAnswer == quiz.infoAnswer){
        //             console.log("정답");
        //         } else {
        //             console.log("오답");
        //         }
        //     });
        // }
        // answerQuiz();

        // 정답 확인
        const answerQuiz = (index) => {
            const quizChoices = document.querySelectorAll(`.quiz__choice input[name="choice${index}"]:checked`);
            const answerElement = quizWrap.querySelectorAll(".quiz__answer")[index];
            const descElement = quizWrap.querySelectorAll(".quiz__desc")[index];
            const quizElement = quizWrap.querySelectorAll(".quiz")[index];

            if (quizChoices.length > 0) {
                const userAnswer = quizChoices[0].value;

                if (userAnswer === quizInfo[index].infoAnswer) {
                    answerElement.textContent = "정답입니다!";
                    quizElement.classList.add("good");
                    quizElement.classList.remove("bad");
                    answerElement.classList.remove("none");
                    descElement.classList.remove("none");

                    totalScore++;
                    quizScore.innerHTML = totalScore;
                } else {
                    answerElement.textContent = "오답입니다!";
                    quizElement.classList.add("bad");
                    quizElement.classList.remove("good");
                    answerElement.classList.remove("none");
                    descElement.classList.remove("none");
                }
            }
        }

        // 페이지가 로드된 후 실행
        document.addEventListener("DOMContentLoaded", () => {
            updateQuiz();

            const confirmButtons = document.querySelectorAll(".quiz__confirm");
            confirmButtons.forEach((button, index) => {
                button.addEventListener("click", () => {
                    answerQuiz(index);
                });
            });
        });
    </script>
</body>
</html>